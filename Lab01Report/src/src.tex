\section{Метод решения}
Алгоритм нахождения поэлементного минимума двух векторов принимает три вектора (третий используется для вывода результата). 
Далее необходимо найти минимум каждого элемента из двух векторов. Очевидно, что если оба вектора принадлежат пространству $R^n$, то сложность будет $O(n)$.
Каждый поток ищет минимум элементов двух векторов с шагом, равным общему количеству потоков, начиная со своего номера потока.
\section{Описание программы}
Проект я разделил на следущие модули:
\begin{enumerate}
    \item common defines - содержит множество полезных дефайнов для более приятной работы с CUDA и C++.
    \item common structures - содержит класс-обертку над CUDA событиями и класс-обертку над std::stringstream, позволяющим конструировать строки (sprintf с возможностями C++).
    \item operation system - содержит операции, связанные с системными вызовами (например, получение информации о количестве оперативной памяти). Реализован только для ОС Windows.
    \item kernel - непосредственно программа, выполняющия все операции, связанные с вводом, вычислениями и выводом.
\end{enumerate}

Функция ядра сводится к вычислению номера потока, общего количества потоков и циклу с заданным шагом, внутри которого вычисляется минимум двух элементов вектора. 